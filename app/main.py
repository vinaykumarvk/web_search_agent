from __future__ import annotations

from fastapi import BackgroundTasks, Depends, FastAPI, HTTPException

from .models import ResearchTask, ResearchTaskCreate
from .repositories import RepositoryProvider, TaskRepository
from .worker import process_research_task

app = FastAPI(title="Web Research Agent")
_repository_provider = RepositoryProvider()


def get_repository() -> TaskRepository:
    return _repository_provider.get_repository()


@app.post("/research", response_model=ResearchTask, status_code=202)
async def create_research_task(
    payload: ResearchTaskCreate,
    background_tasks: BackgroundTasks,
    repository: TaskRepository = Depends(get_repository),
) -> ResearchTask:
    task = await repository.create_task(payload)
    background_tasks.add_task(process_research_task, task.id, repository)
    return task


@app.get("/research/{task_id}", response_model=ResearchTask)
async def get_research_task(task_id: str, repository: TaskRepository = Depends(get_repository)) -> ResearchTask:
    task = await repository.get_task(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task
import logging

from uuid import uuid4
from typing import Dict

from fastapi import BackgroundTasks, FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware

from .schemas import (
    ResearchControls,
    ResearchRequest,
    ResearchResponse,
    ResearchTaskCreated,
    ResearchTaskStatus,
    ResponseEnvelope,
    ResponseMetadata,
    TaskStatus,
)

logger = logging.getLogger("app")
logging.basicConfig(level=logging.INFO)

app = FastAPI(title="Web Research Agent API", version="0.1.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


class LoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        logger.info("%s %s", request.method, request.url.path)
        response = await call_next(request)
        logger.info("%s %s -> %s", request.method, request.url.path, response.status_code)
        return response


app.add_middleware(LoggingMiddleware)

_tasks: Dict[str, ResearchTaskStatus] = {}


def _build_envelope(request: ResearchRequest, task_id: str, status: TaskStatus) -> ResponseEnvelope:
    controls: ResearchControls = request.controls
    metadata = ResponseMetadata(
        purpose=controls.purpose,
        depth=controls.depth,
        audience=controls.audience,
        region=controls.region,
        timeframe=controls.timeframe,
        task_id=task_id,
        status=status,
    )

    executive_summary = (
        "Quick synthesis placeholder generated by the Web Research Agent API."
    )
    deliverable = (
        f"Requested research on '{request.query}' with depth={controls.depth} and "
        f"audience={controls.audience}."
    )
    assumptions_and_gaps = (
        "Sources are placeholders. Integrate research orchestrator for live data."
    )
    next_steps = [
        "Integrate search/retrieval pipeline for real citations",
        "Add persistence for task state beyond in-memory store",
        "Wire up templating for deliverable variants",
    ]

    return ResponseEnvelope(
        title=f"Research: {request.query}",
        metadata=metadata,
        executive_summary=executive_summary,
        deliverable=deliverable,
        citations=[],
        assumptions_and_gaps=assumptions_and_gaps,
        next_steps=next_steps,
    )


def _complete_task(task_id: str, request: ResearchRequest) -> None:
    logger.info("Completing task %s", task_id)
    envelope = _build_envelope(request, task_id=task_id, status=TaskStatus.COMPLETED)
    _tasks[task_id] = ResearchTaskStatus(
        task_id=task_id,
        status=TaskStatus.COMPLETED,
        envelope=envelope,
    )


@app.get("/health")
async def health() -> dict:
    return {"status": "ok"}


@app.post("/research", response_model=ResearchResponse | ResearchTaskCreated)
async def create_research_job(
    payload: ResearchRequest, background_tasks: BackgroundTasks
):
    if payload.controls.async_mode:
        task_id = str(uuid4())
        _tasks[task_id] = ResearchTaskStatus(
            task_id=task_id,
            status=TaskStatus.PENDING,
            envelope=None,
        )
        background_tasks.add_task(_complete_task, task_id, payload)
        return ResearchTaskCreated(task_id=task_id)

    envelope = _build_envelope(payload, task_id=str(uuid4()), status=TaskStatus.COMPLETED)
    return ResearchResponse(envelope=envelope)


@app.get("/research/{task_id}", response_model=ResearchTaskStatus)
async def get_research_task(task_id: str):
    task = _tasks.get(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task


@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    logger.error("HTTP error %s: %s", exc.status_code, exc.detail)
    return JSONResponse(status_code=exc.status_code, content={"error": exc.detail})


@app.exception_handler(Exception)
async def unhandled_exception_handler(request: Request, exc: Exception):
    logger.exception("Unhandled error: %s", exc)
    return JSONResponse(status_code=500, content={"error": "Internal server error"})
